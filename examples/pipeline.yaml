---
name: default

transform_rules:
- name: jnx-naming-convention
  description: |
    Extract the different elements from the Japannext naming convention
  if: 'alert.Source.Kind == "otlp" && alert.Labels["host.name"] =~ "[a-z]{3}[0-9][a-z]+[0-9]+"'
  childs:
  - set:
      target: 'alert.Label["jnx.domain"]'
      value: 'japannext.co.jp'
  - regex:
      source: 'alert.Label["host.name"]'
      pattern: '(?P<prefix>[a-z]{3}[0-9])(?P<server_role>[a-z]+)(?P<nodenum>[0-9]+)'
      targets:
        prefix: 'alert.Labels["jnx.prefix"]'
        server_role: 'alert.Labels["jnx.server_role"]'
        nodenum: 'alert.Labels["jnx.nodenum"]'
  - group_by:
      fields:
      - 'alert.Labels["jnx.prefix"]'
      - 'alert.Labels["jnx.server_role"]'
      - 'alert.Labels["process.name"]'

profiles:
- group: KernelErrors
  switch: {key: identity.process, value: kernel}
  patterns:
  - name: KernelWatchdog
    regex: "watchdog did not stop!"
    group_by:
    - identity.host
    extra_labels:
      pattern.url: https://...
      owner: unix
- group: SSHErrors
  switch: {key: identity.process, value: sshd}
  patterns:
  - name: SshLoginFailed
    regex: >
      Failed (?P<method>.*?) for (?P<user>.*?) from (?P<sourceIP>.*?) port (?P<port>[0-9]+) ssh2
    group_by: [capture.user]
    extra_labels:
      owner: cybersecurity
      user: '{{ .capture.user }}'
      sourceIP: '{{ .capture.sourceIP }}'
      authMethod: '{{ .capture.method }}'
  - name: SshKexExchanceIdentification
    regex: 'error: kex_exchange_identification: Connection closed by remote host'
    drop: true
  - name: SshConnectionReset
    regex: 'Connection reset by peer'
    drop: true
  - group_by: [identity.host]
    default: true
- group: HaproxyErrors
  switch: {key: identity.process, value: haproxy}
  patterns:
  - name: HaproxyServerDown
    regex: >
      Server (?P<backend>.*?)/(?P<server>.*?) is DOWN, reason: (?P<reason>.*?),
    identity_override:
      kind: haproxy
      backend: '{{ .capture.backend }}'
      server: '{{ .capture.server }}'
    extra_labels:
      backend: '{{ .capture.backend }}'
      reason: '{{ .capture.reason }}'
  - name: HaproxyBackendDown
    regex: >
      backend (?P<backend>.*?) has no server available!
    identity_override:
      kind: haproxy
      backend: '{{ .capture.backend }}'
- group: PacemakerErrors
  switch: {key: identity.process, value: pengine}
  patterns:
  - name: PacemakerTransitionError
    regex: 'error: Calculated transition (?P<transitions>[0-9]+) (with errors), saving inputs in (?P<path>.*)'
- group: RsyslogClientErrors
  switch: {key: identity.process, value: rsyslogd}
  patterns:
  - name: RsyslogRelpError
    regex: "omrelp.*action may not work as intended"

default_grouping_rules:
- if: 'has labels[jnx.service]'
  group_by: ['labels[jnx.service]', 'labels[jnx.env]']
- if: 'has labels[jnx.role]'
  group_by: ['labels[jnx.role]', 'labels[jnx.prefix]']

silence_rules:
- if: 'labels[process.name] = "icingaweb" and body[message] =~ "connection reset"'
- if: 'labels[host.name] =~ "^mmi1"'
  weekly_schedule:
    from: {day: friday, time: '17:30'}
    to: {day: monday, time: '07:00'}
- if: 'labels[process.name] =~ "myapp"'
  daily_schedule:
    from: {time: '10:00'}
    to: {time: '17:00'}

groupings:
- name: by-hosts
  groupBy:
  - identity.host
- name: by-app
  groupBy:
  - identity.host
  - identity.process

ratelimits:
- name: by-hosts
  group: by-hosts
  countPerPeriod: 100
  period: 1m
- name: by-app
  group: by-app
  countPerPeriod: 100
  period: 1m

notificaton_rules:
- if: 'labels.owner == "unix"'
  channels: ['googlechat:unix']
  continue: true
- if: 'labels.env == "prod"'
  channels: ['patlite:red']

default_notification_channels:
- 'googlechat:unix'
- 'googlechat:monitoring'
- 'patlite:purple'
